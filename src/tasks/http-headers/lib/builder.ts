import _ from 'lodash'
import Link from './link'
import Meta from './meta'
import Provider from './providers'
import type { Filesystem, IAssetsManifest } from '@postbuild'
import type { IHttpHeadersTaskOptions, IHeadersMap, IPathHeadersMap } from '../options'

export enum PathPlaceholder {
  All = '[*]',
  Pages = '[pages]',
  PageData = '[page-data]',
  Static = '[static]',
  Assets = '[assets]',
}

/**
 * Cache control headers
 */
const HEADER_CACHE_IMMUTABLE = 'public, max-age=31536000, immutable'
const HEADER_CACHE_NEVER = 'public, max-age=0, must-revalidate'

/**
 * Default security headers
 */
const HEADERS_SECURITY: IPathHeadersMap = {
  [PathPlaceholder.All]: {
    'x-frame-options': 'DENY',
    'x-xss-protection': '1; mode=block',
    'x-content-type-options': 'nosniff',
    'referrer-policy': 'same-origin',
  },
}

/**
 * Default caching headers
 */
const HEADERS_CACHING: IPathHeadersMap = {
  [PathPlaceholder.Pages]: {
    'cache-control': HEADER_CACHE_NEVER,
  },
  [PathPlaceholder.PageData]: {
    'cache-control': HEADER_CACHE_NEVER,
  },
  [PathPlaceholder.Static]: {
    'cache-control': HEADER_CACHE_IMMUTABLE,
  },
  [PathPlaceholder.Assets]: {
    'cache-control': HEADER_CACHE_IMMUTABLE,
  },
  // Service worker generated by `gatsby-plugin-offline`
  '/sw.js': {
    'cache-control': HEADER_CACHE_NEVER,
  },
}

/**
 * Headers file builder
 */
export default class Builder {
  headers: IPathHeadersMap
  readonly pages = new Map<string, { readonly links: Link[]; readonly metas: Meta[] }>()

  readonly provider: Provider
  readonly options: IHttpHeadersTaskOptions
  readonly assets: IAssetsManifest
  readonly fs: Filesystem
  readonly pathPrefix: string
  constructor(
    options: IHttpHeadersTaskOptions,
    assets: IAssetsManifest,
    fs: Filesystem,
    pathPrefix: string,
  ) {
    this.provider = Provider.factory(options, fs)
    this.options = options
    this.assets = assets
    this.fs = fs
    this.pathPrefix = pathPrefix
    this.headers = {
      ...(options.security ? HEADERS_SECURITY : {}),
      ...(options.caching ? HEADERS_CACHING : {}),
    }
  }

  /**
   * Adds a Link to a page path
   */
  addPageLink(page: string, link: Link) {
    this.getOrCreatePage(page).links.push(link)
  }

  /**
   * Adds a Meta to a page path
   */
  addPageMeta(page: string, meta: Meta) {
    this.getOrCreatePage(page).metas.push(meta)
  }

  /**
   * Strips gatsby's pathPrefix from a given href
   */
  normalizeHref(href: string) {
    if (this.pathPrefix !== '' && href.startsWith(this.pathPrefix)) {
      const normalized = href.slice(this.pathPrefix.length)
      return normalized === '' ? '/' : normalized
    }
    return href
  }

  processHeaderValue(value: string[]): string[]
  processHeaderValue(value: string): string
  processHeaderValue(value: string | string[]): string | string[] {
    if (Array.isArray(value)) {
      return value.map((item) => this.processHeaderValue(item) as string)
    }

    const matches = value.match(/\[(\w+):([^\]]+)]/)
    if (matches?.[1] != null && matches[2]) {
      const placeholder = matches[1].toLowerCase()
      const placeholderValue = matches[2]

      if (placeholder === 'asset') {
        const asset = placeholderValue.slice(1)
        if (this.assets.has(asset)) {
          return value.replace(matches[0], '/' + (this.assets.get(asset) as string))
        }
        throw new Error(`Unable to find asset "${placeholderValue}" in value "${value}"`)
      }

      throw new Error(`Invalid dynamic placeholder "${placeholder}" in value "${value}"`)
    }

    return value
  }

  protected isPathPlaceholder(path: string): path is PathPlaceholder {
    return /^\[[^\]]+]$/.test(path)
  }

  protected getUserHeaders(): IPathHeadersMap {
    const placeholders = Object.values(PathPlaceholder)
    const multiValueHeaders = ['link']

    const source = this.options.headers
    const dest: IPathHeadersMap = {}
    for (const [path, headers] of Object.entries(source)) {
      if (this.isPathPlaceholder(path) && !placeholders.includes(path)) {
        throw new Error(
          `Invalid path placeholder "${path}". ` +
            `Available placeholders are: ${placeholders.join(', ')}`,
        )
      }

      dest[path] = {}
      for (const [key, rawValue] of Object.entries(headers)) {
        const name = key.toLowerCase()
        if (name in dest[path]) {
          throw new Error(`Header name "${name}" cannot be defined twice`)
        }
        if (Array.isArray(rawValue) && !multiValueHeaders.includes(name)) {
          throw new TypeError(
            `Value for Header name "${name}" must be a string. ` +
              `Headers with multi-value support are: ${multiValueHeaders.join(', ')}`,
          )
        }
        dest[path][name] = this.processHeaderValue(rawValue as any)
      }
    }

    return dest
  }

  protected mergeHeaders(dest: IHeadersMap, source?: IHeadersMap): IHeadersMap {
    if (!source) return dest
    for (const [name, value] of Object.entries(source)) {
      if (name in dest && Array.isArray(value) && Array.isArray(dest[name])) {
        dest[name] = [...value, ...(dest[name] as string[])]
        continue
      }
      dest[name] = Array.isArray(value) ? [...value] : value
    }
    return dest
  }

  /**
   * Builds the headers file
   */
  async build() {
    const userHeaders = this.getUserHeaders()
    for (const [path, header] of Object.entries(userHeaders)) {
      if (path in this.headers) {
        this.mergeHeaders(this.headers[path], header)
      } else {
        this.headers[path] = header
      }
    }

    this.assets.forEach((hashed, original) => {
      let hashedPath = `/${hashed}`
      let originalPath = `/${original}`
      if (hashedPath.startsWith('/static/') || originalPath === '/styles.css') {
        return
      }
      const hasUserHeaders = originalPath in this.headers
      const assetDefaults = this.headers[PathPlaceholder.Assets]
      this.headers[hashedPath] = this.mergeHeaders({ ...assetDefaults }, this.headers[originalPath])
      if (hasUserHeaders) {
        delete this.headers[originalPath]
      }
    })

    for (const [path, page] of this.pages.entries()) {
      const pathHeaders: IHeadersMap = {}

      // Add meta headers first
      // @todo: Validate the return value of a user-defined callback
      const metas = this.options.transformPathMetas(page.metas, path)
      for (const meta of _.sortBy(metas, 'priority')) {
        const key = meta.header.toLowerCase()
        const acceptsMultiValue = Meta.MULTI_VALUE_META_HEADERS.includes(key)
        const value = meta.value

        if (key in pathHeaders) {
          if (acceptsMultiValue) {
            const existing = pathHeaders[key]
            // allow multiple values
            pathHeaders[key] = Array.isArray(existing)
              ? [...existing, value]
              : [existing as string, value]
          } else {
            pathHeaders[key] = value
          }
        } else {
          pathHeaders[key] = acceptsMultiValue ? [value] : value
        }
      }

      // Add link headers
      // @todo: Validate the return value of a user-defined callback
      const links = this.options.transformPathLinks(page.links, path)
      pathHeaders.link = _.sortBy(links, 'priority').map((link) => String(link))

      this.mergeHeaders(pathHeaders, this.headers[PathPlaceholder.Pages])
      this.headers[path] = this.mergeHeaders(pathHeaders, this.headers[path])
    }

    const headers: IPathHeadersMap = {}
    const omitPlaceholders = [PathPlaceholder.Pages, PathPlaceholder.Assets]
    for (const [path, header] of Object.entries(this.headers)) {
      if (omitPlaceholders.includes(path as PathPlaceholder) || Object.keys(header).length === 0) {
        continue
      }
      headers[this.provider.processPath(path)] = header
    }

    const filename = this.provider.getFilename()
    try {
      const data = await this.provider.build(headers)
      await this.fs.create(filename, data)
    } catch (e: any) {
      throw new Error(`Unable to write headers file "${filename}": ${String(e.message)}`)
    } finally {
      this.pages.clear()
    }
  }

  private getOrCreatePage(path: string) {
    let page = this.pages.get(path)
    if (!page) {
      page = { links: [], metas: [] }
      this.pages.set(path, page)
    }
    return page
  }
}
